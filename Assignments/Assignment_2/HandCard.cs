using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BattleshipHiddenThreat
{
    public partial class HandCard : Card
    {
        //Instance variables
        //############################################
        //Variables   ||Explanation
        //name_       ||The name of hand card
        //mode_       ||The game mode
        //cardsIndex_ ||The index of card in deck need to be selected
        //currentIndexOfCardsIndex_||The index of cardsIndex_ to choose a random number
        //restDestructionCards_||The rest of deck card
        //usedDestructionCards_||The used of cards in deck
        //inHandCards_||The player hand cards
        //rand_       ||Random number generator 
        private string name_;
        private string mode_;
        private int[] cardsIndex_;
        private int currentIndexOFCardsIndex_;
        private List<HandCard> restDestructionCards_;
        private List<HandCard> usedDestructionCards_;
        private List<HandCard> inHandCards_;
        private static Random rand_ = new Random();

        //Constructor
        /// <summary>
        /// Main constructor
        /// </summary>
        /// <param name="NAME"></param>
        /// <param name="MODE"></param>
        public HandCard(string NAME, string MODE) : base(NAME)
        {
            name_ = Name;
            mode_ = MODE;
            restDestructionCards_ = new List<HandCard>();
            usedDestructionCards_ = new List<HandCard>();
            inHandCards_ = new List<HandCard>();
            currentIndexOFCardsIndex_ = 0;
            initialRestDeckCards();
            randomCards();
            drawCards(5);
        }
        /// <summary>
        /// Other constructor
        /// </summary>
        /// <param name="NAME"></param>
        public HandCard(string NAME) : base(NAME)
        {
            name_ = NAME;
        }

        //Private methods
        /// <summary>
        /// Initialise the rest deck of cards
        /// Just one by one
        /// </summary>
        private void initialRestDeckCards()
        {
            //10 white pegs
            for (int i = 0; i < 10; i++)
            {
                restDestructionCards_.Add(new Peg("White Peg", 1, "White"));
            }
            //6 red 1 pegs
            for (int i = 0; i < 6; i++)
            {
                restDestructionCards_.Add(new Peg("Red Peg", 1, "Red"));
            }
            //3 red 2 pegs
            for (int i = 0; i < 3; i++)
            {
                restDestructionCards_.Add(new Peg("Red Peg", 2, "Red"));
            }
            //1 red 4 peg
            restDestructionCards_.Add(new Peg("Red Peg", 4, "Red"));
            //If it is full game
            if (mode_ == "Full")
            {
                //Add power cards to deck
                restDestructionCards_.Add(new Power("Shield"));
                restDestructionCards_.Add(new Power("Shield"));
                restDestructionCards_.Add(new Power("Discard White Peg or Play 2 Cards"));
                restDestructionCards_.Add(new Power("Discard White Peg or Play 2 Cards"));
                restDestructionCards_.Add(new Power("Repair a ship or Draw 3 Cards, then Play 1"));
                restDestructionCards_.Add(new Power("Repair a ship or Draw 3 Cards, then Play 1"));
            }
        }

        /// <summary>
        /// We random the cards by using an array to hold random number 
        /// This random number uses as index in rest card deck
        /// </summary>
        private void randomCards()
        {
            //index in cardsIndex array
            int index = 0;
            //randIndex is the generated by generator
            int randIndex = 0;
            //Set the length of array
            cardsIndex_ = new int[restDestructionCards_.Count];
            //While the full index is generated
            while (index != restDestructionCards_.Count - 1)
            {
                //Generate one number
                randIndex = rand_.Next(restDestructionCards_.Count);
                //Check if we already have this number
                if (!cardsIndex_.Contains(randIndex))
                {
                    //Add to array
                    cardsIndex_[index] = randIndex;
                    //Index add up
                    index++;
                }
            }


        }

        /// <summary>
        /// Draw new card to player hand card
        /// </summary>
        /// <param name="HowManyCardsToDraw">How many cards need to be drawn</param>
        public void drawCards(int HowManyCardsToDraw)
        {
            //If it is great than or equal to 0
            if (HowManyCardsToDraw >= 0)
            {
                //And if it is full game
                if (this.mode_ == "Full")
                {
                    //Loop how many cards to draw
                    for (int i = 0; i < HowManyCardsToDraw; i++)
                    {
                        //If the currentIndexOFCardsIndex_ is small than the rest deck card
                        if (currentIndexOFCardsIndex_ < restDestructionCards_.Count)
                        {
                            //Add card to in hand card
                            inHandCards_.Add(restDestructionCards_[cardsIndex_[currentIndexOFCardsIndex_]]);
                            //index add up
                            currentIndexOFCardsIndex_++;
                        }
                        else
                        {
                            //If the cards Index is over than the restdestructioncards count
                            //Then exchange two decks
                            deckExchange();
                            //random cards
                            randomCards();
                            //re set the current index to 0
                            currentIndexOFCardsIndex_ = 0;
                            //Draw new cards
                            inHandCards_.Add(restDestructionCards_[cardsIndex_[currentIndexOFCardsIndex_]]);
                            //index add up
                            currentIndexOFCardsIndex_++;
                        }
                    }
                }
                else
                {
                    //If it is base game
                    for (int i = 0; i < HowManyCardsToDraw; i++)
                    {
                        //as same logic as above
                        if (currentIndexOFCardsIndex_ < restDestructionCards_.Count)
                        {
                            inHandCards_.Add(restDestructionCards_[cardsIndex_[currentIndexOFCardsIndex_]]);
                            currentIndexOFCardsIndex_++;
                        }
                        else
                        {
                            deckExchange();
                            randomCards();
                            currentIndexOFCardsIndex_ = 0;
                            inHandCards_.Add(restDestructionCards_[cardsIndex_[currentIndexOFCardsIndex_]]);
                            currentIndexOFCardsIndex_++;
                        }
                    }

                }
            }
        }

        /// <summary>
        /// deck exchange, the reference give to restDestructionCards
        /// </summary>
        private void deckExchange()
        {
            restDestructionCards_ = usedDestructionCards_;
        }

        /// <summary>
        /// Discard one hand card
        /// </summary>
        /// <param name="whichToDiscard">Player pass a card to discard it</param>
        public void discards(HandCard whichToDiscard)
        {
            //Add the card to usedDestructionCard
            usedDestructionCards_.Add(whichToDiscard);
        }

        /// <summary>
        /// Override the inheritant method
        /// </summary>
        /// <param name="target">Player pass a card to use</param>
        public override void useCard(Card target)
        {
            //Note: Player use one card and then use the card's useCard method, not the method here!
        }

        //Properties
        public List<HandCard> InHandCards
        {
            get
            {
                return inHandCards_;
            }
        }
    }
}
